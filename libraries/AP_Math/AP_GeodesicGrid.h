/*
 * Copyright (C) 2016  Intel Corporation. All rights reserved.
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file AP_GeodesicGrid.h
 * @brief Geodesic icosahedral grid for efficient 3D direction mapping and spatial indexing
 * 
 * This file provides a geodesic grid implementation based on an icosahedron tessellated
 * by a factor of 2, creating 80 uniform triangular sections on a unit sphere. The grid
 * enables efficient spatial indexing and lookup of 3D directions, which is particularly
 * useful for mapping directional sensor data such as compass calibration points and
 * sensor field measurements.
 * 
 * The implementation uses precomputed inverse change-of-basis matrices for performance
 * optimization on embedded systems, trading memory usage for computational efficiency.
 * 
 * @note This geodesic grid is used in ArduPilot for compass calibration, where it helps
 *       organize and analyze magnetic field measurements taken from different vehicle
 *       orientations to compute calibration parameters.
 * 
 * @note The precomputed tables (_inverses, _mid_inverses, _neighbor_umbrellas) are
 *       generated by Python scripts in the tools/ directory to ensure accuracy and
 *       maintainability.
 * 
 * @see https://en.wikipedia.org/wiki/Geodesic_grid for background on geodesic grids
 */
#pragma once

#include "AP_Math.h"

/**
 * @class AP_GeodesicGrid
 * @brief Geodesic grid for spatial indexing of 3D unit vectors on a tessellated icosahedron
 *
 * @details AP_GeodesicGrid provides efficient spatial indexing for 3D directions by
 * subdividing an icosahedron into 80 uniform triangular sections. This creates a
 * nearly uniform grid on a unit sphere, enabling fast lookup and organization of
 * directional data.
 *
 * ## Coordinate System
 * All vectors are assumed to lie on (or project to) a unit sphere in 3D Cartesian space.
 * The grid operates in standard 3D coordinates with no special frame conventions.
 *
 * ## Tessellation Process
 * The grid is formed by a tessellation of an icosahedron by a factor of 2:
 * 1. Start with a regular icosahedron (20 triangular faces)
 * 2. Split each edge of each triangle into 2 segments
 * 3. Project the new vertices onto the icosahedron's circumscribed sphere
 * 4. This creates 4 sub-triangles per original triangle, totaling 80 sections
 *
 * ## Section Indexing
 * A section index uniquely identifies one of the 80 triangular regions:
 * - Let i ∈ [0,20) be the icosahedron triangle index
 * - Let j ∈ [0,4) be the sub-triangle index within that triangle
 * - The section index s = 4 * i + j
 *
 * ## Relationship Between Triangle and Section Indices
 * The 20 icosahedron triangles (T_0 through T_19) form the basis for section indexing.
 * Each triangle T_i contains 4 sections with indices [4*i, 4*i+1, 4*i+2, 4*i+3].
 *
 * ## Icosahedron Triangle Definition
 * The icosahedron's triangles are defined by the tuple (T_0, T_1, ..., T_19),
 * where T_i is the i-th triangle. Each triangle is represented with a tuple of
 * the form (a, b, c), where a, b and c are the triangle vertices in the space.
 *
 * Given the definitions above and the golden ratio as g, the triangles must
 * be defined in the following order:
 *
 *     (
 *         ((-g, 1, 0), (-1, 0,-g), (-g,-1, 0)),
 *         ((-1, 0,-g), (-g,-1, 0), ( 0,-g,-1)),
 *         ((-g,-1, 0), ( 0,-g,-1), ( 0,-g, 1)),
 *         ((-1, 0,-g), ( 0,-g,-1), ( 1, 0,-g)),
 *         (( 0,-g,-1), ( 0,-g, 1), ( g,-1, 0)),
 *         (( 0,-g,-1), ( 1, 0,-g), ( g,-1, 0)),
 *         (( g,-1, 0), ( 1, 0,-g), ( g, 1, 0)),
 *         (( 1, 0,-g), ( g, 1, 0), ( 0, g,-1)),
 *         (( 1, 0,-g), ( 0, g,-1), (-1, 0,-g)),
 *         (( 0, g,-1), (-g, 1, 0), (-1, 0,-g)),
 *         -T_0,
 *         -T_1,
 *         -T_2,
 *         -T_3,
 *         -T_4,
 *         -T_5,
 *         -T_6,
 *         -T_7,
 *         -T_8,
 *         -T_9,
 *     )
 *
 * Where for a given T_i = (a, b, c), -T_i = (-a, -b, -c). We call -T_i the
 * opposite triangle of T_i in this specification. For any i in [0,20), T_j is
 * the opposite of T_i iff j = (i + 10) % 20.
 *
 * ## Sub-triangle Definition
 * Let an icosahedron triangle T be defined as T = (a, b, c). The "middle
 * triangle" M is defined as the triangle formed by the points that bisect the
 * edges of T. M is defined by:
 *
 *     M = (m_a, m_b, m_c) = ((a + b) / 2, (b + c) / 2, (c + a) / 2)
 *
 * Let elements of the tuple (W_0, W_1, W_2, W_3) comprise the sub-triangles of
 * T, so that W_j is the j-th sub-triangle of T. The sub-triangles are defined
 * as the following:
 *
 *    W_0 = M
 *    W_1 = (a, m_a, m_c)
 *    W_2 = (m_a, b, m_b)
 *    W_3 = (m_c, m_b, c)
 *
 * @note This geodesic grid is used extensively in ArduPilot for compass calibration,
 *       where it organizes magnetic field samples taken from different vehicle orientations.
 *       The uniform spatial distribution ensures good coverage of the measurement sphere,
 *       leading to more accurate calibration parameters.
 *
 * @note The grid is also used for sensor field mapping applications where directional
 *       data needs to be efficiently organized and retrieved based on spatial proximity.
 *
 * @note The implementation uses precomputed inverse change-of-basis matrices (_inverses
 *       and _mid_inverses) to optimize performance on resource-constrained embedded systems.
 *       This represents a memory/computation tradeoff: storing precomputed tables reduces
 *       runtime calculation at the cost of approximately 480 bytes of flash memory.
 *
 * @note The precomputed tables are generated by Python scripts located in the tools/
 *       directory. These scripts ensure mathematical accuracy and make it easier to
 *       maintain and verify the geodesic grid structure.
 *
 * @warning The subdivision calculations involve floating-point arithmetic and coordinate
 *          transformations that can accumulate numerical errors. Vectors very close to
 *          section boundaries may exhibit slight inconsistencies due to floating-point
 *          precision limits. For robust applications, use the inclusive parameter in
 *          the section() method to handle boundary cases appropriately.
 *
 * @see https://en.wikipedia.org/wiki/Geodesic_grid for background information on geodesic grids
 * @see AP_Compass for primary usage in compass calibration
 */
class AP_GeodesicGrid {
    friend class GeodesicGridTest;

public:
    /*
     * The following concepts are used by the description of this class'
     * members.
     *
     * Vector crossing objects
     * -----------------------
     * We say that a vector v crosses an object in space (point, line, line
     * segment, plane etc) iff the line, being Q the set of points of that
     * object, the vector v crosses it iff there exists a positive scalar alpha
     * such that alpha * v is in Q.
     */

    /**
     * @brief Number of sub-triangles created per icosahedron triangle face
     * 
     * Each of the 20 icosahedron triangles is subdivided into 4 sub-triangles,
     * resulting in 80 total sections across the geodesic grid.
     */
    static const int NUM_SUBTRIANGLES = 4;

    /**
     * @brief Find which geodesic grid section is crossed by a given 3D vector
     *
     * This method determines which of the 80 triangular sections on the tessellated
     * icosahedron a given vector passes through. The vector is treated as a direction
     * from the origin, and the method finds which section that direction intersects
     * on the unit sphere.
     *
     * @param[in] v The 3D vector to be tested. Does not need to be normalized, as
     *              only the direction matters. If v is the zero vector, -1 is returned.
     *
     * @param[in] inclusive Controls behavior for vectors that lie exactly on section
     *                      boundaries (edges between sections):
     *                      - true: If v crosses a section edge, one of the adjacent
     *                        sections is returned (which one is unspecified)
     *                      - false: If v crosses a section edge exactly, -1 is returned
     *                        to indicate ambiguity
     *                      Default value is false for strict section membership testing.
     *
     * @return The section index in the range [0, 79], or -1 if:
     *         - v is the zero vector, or
     *         - v lies exactly on a section boundary and inclusive is false
     *
     * @note The section index s relates to the icosahedron triangle index i and
     *       sub-triangle index j by: s = 4 * i + j, where i ∈ [0,20) and j ∈ [0,4)
     *
     * @note When inclusive is true and v lies on a boundary, the returned section
     *       is deterministic for a given input but the choice between adjacent sections
     *       is implementation-defined. Do not rely on which section is chosen.
     *
     * @warning Due to floating-point precision limitations, vectors very close to
     *          boundaries may exhibit non-deterministic behavior across different
     *          platforms or compiler optimizations. Use inclusive=true for robust
     *          handling of boundary cases in production code.
     *
     * @see section() for usage in compass calibration algorithms
     */
    static int section(const Vector3f &v, bool inclusive = false);

private:
    /*
     * The following are concepts used in the description of the private
     * members.
     *
     * Neighbor triangle with respect to an edge
     * -----------------------------------------
     * Let T be a triangle. The triangle W is a neighbor of T with respect to
     * edge e if T and W share that edge. If e is formed by vectors a and b,
     * then W can be said to be a neighbor of T with respect to a and b.
     *
     * Umbrella of a vector
     * --------------------
     * Let v be one vertex of the icosahedron. The umbrella of v is the set of
     * icosahedron triangles that share that vertex. The vector v is called the
     * umbrella's pivot.
     *
     * Let T have vertices v, a and b. Then, with respect to (a, b):
     *  - The vector a is the umbrella's 0-th vertex.
     *  - The vector b is the 1-th vertex.
     *  - The triangle formed by the v, the i-th and ((i + 1) % 5)-th vertex is
     *  the umbrella's i-th component.
     *  - For i in [2,5), the i-th vertex is the vertex that, with the
     *  (i - 1)-th and v, forms the neighbor of the (i - 2)-th component with
     *  respect to v and the (i - 1)-th vertex.
     *
     * Still with respect to (a, b), the umbrella's i-th component is the
     * triangle formed by the i-th and ((i + 1) % 5)-th vertices and the pivot.
     *
     * Neighbor umbrella with respect to an icosahedron triangle's edge
     * ----------------------------------------------------------------
     * Let T be an icosahedron triangle. Let W be the T's neighbor triangle wrt
     * the edge e. Let w be the W's vertex that is opposite to e. Then the
     * neighbor umbrella of T with respect to e is the umbrella of w.
     */

    /**
     * @brief Precomputed inverse change-of-basis matrices for icosahedron triangles
     *
     * The i-th matrix is the inverse of the change-of-basis matrix from the
     * standard (natural) 3D Cartesian basis to the basis formed by the vertices
     * of triangle T_i.
     *
     * @details These matrices enable efficient transformation of a vector from
     * standard coordinates into the local coordinate system of each icosahedron
     * triangle. By precomputing the inverses (which are expensive to calculate),
     * we can quickly determine if a vector lies within a particular triangle
     * using simple coordinate tests.
     *
     * @note Only 10 matrices are stored because triangles T_10 through T_19 are
     *       the opposite (negated) versions of T_0 through T_9. The inverse for
     *       triangle T_{i+10} can be derived from the inverse for T_i.
     *
     * @note These precomputed tables are generated by Python scripts in the tools/
     *       directory to ensure mathematical accuracy and to facilitate verification.
     *
     * @note This represents a memory/computation tradeoff optimized for embedded
     *       systems: storing 10 Matrix3f objects (~120 bytes) eliminates the need
     *       for runtime matrix inversion, which would be computationally expensive
     *       and potentially numerically unstable on every section lookup.
     */
    static const Matrix3f _inverses[10];

    /**
     * @brief Precomputed inverse change-of-basis matrices for middle triangles
     *
     * The i-th matrix is the inverse of the change-of-basis matrix from the
     * standard (natural) 3D Cartesian basis to the basis formed by the vertices
     * of the middle triangle M_i of icosahedron triangle T_i.
     *
     * @details The middle triangle is formed by bisecting the edges of the parent
     * icosahedron triangle. These inverse matrices enable efficient determination
     * of which sub-triangle (0-3) a vector crosses within a parent triangle.
     *
     * @note Only 10 matrices are stored for the same symmetry reasons as _inverses:
     *       the opposite triangles T_10 through T_19 can reuse computations from
     *       T_0 through T_9.
     *
     * @note Precomputing these matrices avoids expensive runtime calculations during
     *       section lookups, which may be performed frequently in calibration and
     *       sensor mapping algorithms. The memory cost (~120 bytes) is justified by
     *       the performance improvement on resource-constrained flight controllers.
     */
    static const Matrix3f _mid_inverses[10];

    /**
     * @brief Precomputed representation of neighbor umbrellas for triangle T_0
     *
     * The values for the neighbors of T_10 can be derived from the values for
     * T_0. How to find the correct values is explained on each member.
     *
     * @details This structure encodes the topological relationships between adjacent
     * triangles on the icosahedron. An "umbrella" is the set of triangles sharing
     * a common vertex. Precomputing these relationships enables efficient traversal
     * of the geodesic grid when determining which section a boundary vector crosses.
     *
     * Let T_0 = (a, b, c). Thus, 6 indexes can be used for this data
     * structure, so that:
     *  - index 0 represents the neighbor of T_0 with respect to (a, b).
     *  - index 1 represents the neighbor of T_0 with respect to (b, c).
     *  - index 2 represents the neighbor of T_0 with respect to (c, a).
     *  - index 3 represents the neighbor of T_10 with respect to (-a, -b).
     *  - index 4 represents the neighbor of T_10 with respect to (-b, -c).
     *  - index 5 represents the neighbor of T_10 with respect to (-c, -a).
     *
     * Those indexes are mapped to this array with index % 3.
     *
     * The edges are represented with pairs because the order of the vertices
     * matters to the order the triangles' indexes are defined - the order of
     * the umbrellas' vertices and components is conventioned to be with
     * respect to those pairs.
     *
     * @note This is another example of the memory/computation tradeoff in this
     *       implementation. Storing 3 neighbor_umbrella structures (~40 bytes total)
     *       eliminates the need to compute topological relationships at runtime,
     *       which would require complex geometric calculations.
     *
     * @note These precomputed neighbor relationships are generated and verified by
     *       scripts in the tools/ directory to ensure the icosahedron topology is
     *       correctly encoded.
     */
    static const struct neighbor_umbrella {
        /**
         * The umbrella's components. The value of #components[i] is the
         * icosahedron triangle index of the i-th component.
         *
         * In order to find the components for T_10, the following just finding
         * the index of the opposite triangle is enough. In other words,
         * (#components[i] + 10) % 20.
         */
        uint8_t components[5];
        /**
         * The fields with name in the format vi_cj are interpreted as the
         * following: vi_cj is the index of the vector, in the icosahedron
         * triangle pointed by #components[j], that matches the umbrella's i-th
         * vertex.
         *
         * The values don't change for T_10.
         */
        uint8_t v0_c0;
        uint8_t v1_c1;
        uint8_t v2_c1;
        uint8_t v4_c4;
        uint8_t v0_c4;
    } _neighbor_umbrellas[3];

    /**
     * Get the component_index-th component of the umbrella_index-th neighbor
     * umbrella.
     *
     * @param umbrella_index[in] The neighbor umbrella's index.
     *
     * @param component_index[in] The component's index.
     *
     * @return The icosahedron triangle's index of the component.
     */
    static int _neighbor_umbrella_component(int umbrella_index, int component_idx);

    /**
     * Find the icosahedron triangle index of the component of
     * #_neighbor_umbrellas[umbrella_index] that is crossed by \p v.
     *
     * @param umbrella_index[in] The umbrella index. Must be in [0,6).
     *
     * @param v[in] The vector to be tested.
     *
     * @param u[in] The vector \p u must be \p v  expressed with respect to the
     * base formed by the umbrella's 0-th, 1-th and 3-th vertices, in that
     * order.
     *
     * @param inclusive[in] This parameter follows the same rules defined in
     * #section() const.
     *
     * @return The index of the icosahedron triangle. The value -1 is returned
     * if \p v is the null vector or the triangle isn't found, which might
     * happen when \p inclusive is false.
     */
    static int _from_neighbor_umbrella(int umbrella_index,
                                       const Vector3f &v,
                                       const Vector3f &u,
                                       bool inclusive);

    /**
     * Find which icosahedron's triangle is crossed by \p v.
     *
     * @param v[in] The vector to be verified.
     *
     * @param inclusive[in] This parameter follow the same rules defined in
     * #section() const.
     *
     * @return The index of the triangle. The value -1 is returned if the
     * triangle isn't found, which might happen when \p inclusive is false.
     */
    static int _triangle_index(const Vector3f &v, bool inclusive);

    /**
     * Find which sub-triangle of the icosahedron's triangle pointed by \p
     * triangle_index is crossed by \p v.
     *
     * The vector \p v must belong to the super-section formed by the triangle
     * pointed by \p triangle_index, otherwise the result is undefined.
     *
     * @param triangle_index[in] The icosahedron's triangle index, it must be in
     * the interval [0,20). Passing invalid values is undefined behavior.
     *
     * @param v[in] The vector to be verified.
     *
     * @param inclusive[in] This parameter follow the same rules defined in
     * #section() const.
     *
     * @return The index of the sub-triangle. The value -1 is returned if the
     * triangle isn't found, which might happen when \p inclusive is false.
     */
    static int _subtriangle_index(const unsigned int triangle_index,
                                  const Vector3f &v,
                                  bool inclusive);
};
