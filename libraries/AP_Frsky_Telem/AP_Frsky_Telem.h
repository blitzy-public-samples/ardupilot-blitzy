/*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @file AP_Frsky_Telem.h
 * @brief FrSky telemetry subsystem manager
 * 
 * @details This file defines the main interface class for the FrSky telemetry
 *          subsystem, which manages communication with FrSky RC receivers via
 *          various protocols (D, SPort, SPort Passthrough).
 * 
 *          The AP_Frsky_Telem class implements singleton pattern with lazy
 *          initialization, automatically selecting the appropriate backend
 *          (AP_Frsky_D, AP_Frsky_SPort, or AP_Frsky_SPort_Passthrough) based
 *          on SerialManager configuration.
 * 
 *          Provides external data interface for FPort passthrough mode, where
 *          telemetry data is generated by ArduPilot but exported to external
 *          transport (RC link) rather than transmitted directly on a serial port.
 * 
 *          Supports optional bidirectional communication for parameter access
 *          and commands when HAL_WITH_FRSKY_TELEM_BIDIRECTIONAL is enabled.
 * 
 *          Conditional compilation via AP_FRSKY_TELEM_ENABLED feature flag.
 * 
 * @see AP_Frsky_Backend.h for backend interface
 * @see AP_Frsky_D.h for legacy D protocol backend
 * @see AP_Frsky_SPort.h for basic SPort backend
 * @see AP_Frsky_SPort_Passthrough.h for advanced Passthrough backend
 */
#pragma once

#include "AP_Frsky_config.h"

#if AP_FRSKY_TELEM_ENABLED

#include "AP_Frsky_Backend.h"
#include "AP_Frsky_SPort.h"

class AP_Frsky_Parameters;

/**
 * @class AP_Frsky_Telem
 * @brief Main interface class managing FrSky telemetry subsystem
 * 
 * @details This singleton class manages the FrSky telemetry subsystem, which
 *          provides telemetry data streaming to FrSky RC receivers.
 * 
 *          **Singleton Pattern:**
 *          - Private constructor enforces single instance creation
 *          - Lazy initialization via init() or try_create_singleton_for_external_data()
 *          - Access via get_singleton() or AP::frsky_telem()
 * 
 *          **Backend Selection:**
 *          Automatically selects appropriate backend based on SerialManager
 *          protocol configuration:
 *          - SerialProtocol_FrSky_D (4) → AP_Frsky_D backend
 *            * 9600 baud, legacy D protocol for older receivers
 *          - SerialProtocol_FrSky_SPort (10) → AP_Frsky_SPort backend
 *            * 57600 baud, basic SPort protocol for X-series receivers
 *          - SerialProtocol_FrSky_SPort_Passthrough (10) → AP_Frsky_SPort_Passthrough backend
 *            * 57600 baud, advanced protocol with weighted fair queuing and bidirectional support
 * 
 *          **Supported Protocols:**
 *          1. D Protocol (legacy): 9600 baud, basic telemetry for older receivers
 *          2. SPort Protocol: 57600 baud, standard telemetry for X-series receivers
 *          3. SPort Passthrough: 57600 baud, OpenTX/EdgeTX protocol with enhanced features
 * 
 *          **External Data Interface:**
 *          Provides static methods get_telem_data() and set_telem_data() for
 *          FPort passthrough mode, where telemetry data is generated but not
 *          transmitted directly - instead exported to external transport layer
 *          for transmission over RC link.
 * 
 *          **Bidirectional Support:**
 *          When HAL_WITH_FRSKY_TELEM_BIDIRECTIONAL is enabled, supports
 *          receiving telemetry data for parameter access and command processing.
 * 
 *          **Threading:**
 *          Backends run on dedicated thread with PRIORITY_RCIN priority on
 *          core 1, using 1024 byte stack.
 * 
 *          **Resource Management:**
 *          Backend allocated with NEW_NOTHROW during init(), deallocated in
 *          destructor. Graceful failure on allocation error.
 * 
 * @note Serial port configuration requires SerialManager port configured with
 *       protocol SerialProtocol_FrSky_D (4), SerialProtocol_FrSky_SPort (10),
 *       or SerialProtocol_FrSky_SPort_Passthrough (10)
 * 
 * @warning Backend selection occurs once during init() and cannot be changed
 *          at runtime without reinitialization
 * 
 * @warning When use_external_data=true, telemetry generated but not transmitted
 *          directly - caller responsible for exporting via get_telem_data()
 * 
 * @see AP_Frsky_Backend for backend interface definition
 * @see AP_Frsky_D for legacy D protocol implementation
 * @see AP_Frsky_SPort for basic SPort implementation
 * @see AP_Frsky_SPort_Passthrough for advanced Passthrough implementation
 * @see AP::serialmanager() for serial port configuration
 */
class AP_Frsky_Telem {

public:
    /**
     * @brief Initialize FrSky telemetry manager (private construction for singleton)
     * 
     * @details Constructor initializes member pointers to nullptr but does not
     *          allocate backend or parameters. Actual initialization occurs in
     *          init() method. Registers singleton instance pointer.
     * 
     * @note Private constructor enforces singleton pattern - external code cannot
     *       directly instantiate this class
     * @note Does not allocate backend until init() called to allow configuration
     *       before resource allocation
     */
    AP_Frsky_Telem();

    /**
     * @brief Cleanup backend resources
     * 
     * @details Destructor deletes allocated backend pointer if not nullptr,
     *          ensuring proper cleanup of resources including UART handles
     *          and thread resources.
     * 
     * @note Deletes backend pointer if allocated during init()
     * @note Parameter object (_frsky_parameters) cleanup handled separately
     */
    ~AP_Frsky_Telem();

    /**
     * @brief Prevent copy construction and assignment (singleton pattern)
     * 
     * @details Macro CLASS_NO_COPY deletes copy constructor and copy assignment
     *          operator to enforce singleton pattern. Only one instance of
     *          AP_Frsky_Telem should exist in the system.
     */
    /* Do not allow copies */
    CLASS_NO_COPY(AP_Frsky_Telem);

    /**
     * @brief Initialize FrSky telemetry with backend selection
     * 
     * @details Initialization sequence:
     *          1. Find UART via AP::serialmanager().find_serial() for SerialProtocol_FrSky_*
     *          2. Allocate appropriate backend with NEW_NOTHROW:
     *             - SerialProtocol_FrSky_D → AP_Frsky_D (9600 baud legacy)
     *             - SerialProtocol_FrSky_SPort → AP_Frsky_SPort (57600 baud basic)
     *             - SerialProtocol_FrSky_SPort_Passthrough → AP_Frsky_SPort_Passthrough (57600 baud advanced)
     *          3. Call backend->init(use_external_data) to initialize backend resources
     *          4. Backend spawns dedicated thread for telemetry transmission
     * 
     *          Backend selection based on SerialManager protocol configuration.
     *          Protocol type determines features: D (legacy), SPort (basic),
     *          SPort_Passthrough (advanced with WFQ and bidirectional).
     * 
     * @param[in] use_external_data true for FPort mode where telemetry data
     *                               generated but exported to external transport
     *                               layer rather than transmitted directly on UART.
     *                               false (default) for direct UART transmission.
     * 
     * @return true if backend successfully created and initialized, false if
     *         no FrSky serial port configured or backend allocation fails
     * 
     * @note Backend selection occurs once during this call and cannot change
     *       without reinitialization
     * @note When use_external_data=true, caller must export telemetry via
     *       get_telem_data() for transmission over RC link
     * 
     * @warning Returns false if no FrSky serial port configured in SerialManager
     * @warning Returns false if backend allocation fails (NEW_NOTHROW returns nullptr)
     * @warning Should not be called on armed vehicle - may disrupt telemetry
     * 
     * @see AP::serialmanager() for serial port configuration
     * @see AP_Frsky_Backend::init() for backend initialization details
     */
    // init - perform required initialisation
    bool init(bool use_external_data=false);

    /**
     * @brief Get singleton instance pointer
     * 
     * @details Returns pointer to the singleton instance of AP_Frsky_Telem.
     *          Instance created by init() or try_create_singleton_for_external_data().
     * 
     * @return AP_Frsky_Telem* pointer to singleton instance, or nullptr if
     *         singleton not yet created
     * 
     * @note Instance created during first init() call or deferred creation by
     *       try_create_singleton_for_external_data() for external data mode
     * @note Safe to call before initialization - returns nullptr if not created
     * 
     * @see AP::frsky_telem() for namespace accessor wrapper
     */
    static AP_Frsky_Telem *get_singleton(void) {
        return singleton;
    }

    /**
     * @brief Retrieve telemetry packets for external transport (FPort)
     * 
     * @details Static wrapper for singleton's _get_telem_data() method.
     *          Used by FPort to export telemetry data generated by ArduPilot
     *          over RC link rather than direct serial transmission.
     * 
     *          Retrieves queued SPort telemetry packets from backend for
     *          external transmission. Packets formatted as sport_packet_t
     *          structures ready for SPort framing and transmission.
     * 
     * @param[out] packet_array Buffer to receive telemetry packets, must be
     *                          valid sport_packet_t array
     * @param[in,out] packet_count Input: maximum packets to retrieve (array capacity)
     *                             Output: actual packets retrieved (0 to max_size)
     * @param[in] max_size Maximum array capacity in number of packets, prevents
     *                     buffer overflow
     * 
     * @return true if telemetry data available and retrieved, false if no data
     *         available or singleton not created
     * 
     * @note Static method safe to call before singleton created - returns false
     *       if singleton nullptr
     * @note Used exclusively in external data mode (use_external_data=true in init())
     * @note Caller responsible for SPort framing and physical transmission
     * 
     * @warning Ensure packet_array capacity matches max_size to prevent overflow
     * 
     * @see _get_telem_data() for internal implementation
     * @see AP_Frsky_Backend::sport_packet_t for packet structure definition
     */
    // get next telemetry data for external consumers of SPort data
    static bool get_telem_data(AP_Frsky_Backend::sport_packet_t* packet_array, uint8_t &packet_count, const uint8_t max_size);
#if HAL_WITH_FRSKY_TELEM_BIDIRECTIONAL
    /**
     * @brief Inject telemetry from external source (conditional on HAL_WITH_FRSKY_TELEM_BIDIRECTIONAL)
     * 
     * @details Static wrapper for singleton's _set_telem_data() method.
     *          Used by FPort to inject received telemetry data into ArduPilot
     *          processing for bidirectional communication (parameter access,
     *          command processing).
     * 
     *          Injects SPort telemetry frames received from external transport
     *          into backend for processing. Enables bidirectional features
     *          like parameter tuning from transmitter.
     * 
     * @param[in] frame Frame type identifier (uint8_t), SPort frame format
     * @param[in] appid Application ID (uint16_t), identifies data type
     * @param[in] data Payload data (uint32_t), 32-bit telemetry value
     * 
     * @return true if telemetry accepted and queued for processing, false if
     *         rejected or singleton not created
     * 
     * @note Static method safe to call before singleton created - returns false
     *       if singleton nullptr
     * @note Only compiled when HAL_WITH_FRSKY_TELEM_BIDIRECTIONAL defined
     * @note Used for parameter access and command processing from transmitter
     * 
     * @warning Only enabled in bidirectional builds - check feature flag availability
     * 
     * @see _set_telem_data() for internal implementation
     */
    // set telemetry data from external producer of SPort data
    static bool set_telem_data(const uint8_t frame,const uint16_t appid, const uint32_t data);
#endif

    /**
     * @brief Queue status text message for transmission
     * 
     * @details Queues text message for transmission to ground station via FrSky
     *          telemetry. Messages displayed on OpenTX/EdgeTX transmitter screen
     *          or consumed by Lua scripts.
     * 
     *          Delegates to backend queue_text_message() method. Safe null check
     *          if backend not initialized - silently returns without queuing.
     * 
     * @param[in] severity MAV_SEVERITY level indicating message priority/type
     *                     (EMERGENCY, ALERT, CRITICAL, ERROR, WARNING, NOTICE,
     *                     INFO, DEBUG)
     * @param[in] text Message string to transmit, null-terminated C string
     * 
     * @note Safe to call if backend not initialized - performs nullptr check
     * @note Messages subject to backend queuing and rate limiting
     * @note Message display depends on receiver/transmitter capabilities
     * 
     * @see AP_Frsky_Backend::queue_text_message() for backend implementation
     * @see MAV_SEVERITY for severity level definitions
     */
    void queue_message(MAV_SEVERITY severity, const char *text) {
        if (_backend == nullptr) {
            return;
        }
        return _backend->queue_text_message(severity, text);
    }

private:

    /**
     * @brief Allocated backend instance (AP_Frsky_Backend*, D/SPort/Passthrough variant)
     * 
     * @details Pointer to concrete backend implementation, allocated during init():
     *          - AP_Frsky_D* for D protocol (SerialProtocol_FrSky_D)
     *          - AP_Frsky_SPort* for basic SPort (SerialProtocol_FrSky_SPort)
     *          - AP_Frsky_SPort_Passthrough* for advanced Passthrough (SerialProtocol_FrSky_SPort_Passthrough)
     * 
     *          Backend handles actual telemetry transmission, queuing, and
     *          protocol formatting.
     * 
     * @note nullptr until init() succeeds with backend allocation
     * @note Deleted in destructor to release resources
     */
    AP_Frsky_Backend *_backend;
    
    /**
     * @brief FrSky parameter configuration (AP_Frsky_Parameters*)
     * 
     * @details Pointer to parameter object managing FrSky-specific configuration
     *          parameters for telemetry behavior and protocol options.
     * 
     * @note Allocated and managed separately from backend
     */
    AP_Frsky_Parameters* _frsky_parameters;

    /**
     * @brief Internal implementation of get_telem_data()
     * 
     * @details Instance method implementing telemetry packet retrieval for
     *          external transport. Delegates to backend get_telem_data() if
     *          backend initialized.
     * 
     * @param[out] packet_array Buffer to receive telemetry packets
     * @param[in,out] packet_count Input: max packets, Output: actual packets
     * @param[in] max_size Array capacity in packets
     * 
     * @return true if data available and retrieved, false otherwise
     * 
     * @note Called by static get_telem_data() wrapper after singleton validation
     * @see get_telem_data() for public interface documentation
     */
    // get next telemetry data for external consumers of SPort data (internal function)
    bool _get_telem_data(AP_Frsky_Backend::sport_packet_t* packet_array, uint8_t &packet_count, const uint8_t max_size);
#if HAL_WITH_FRSKY_TELEM_BIDIRECTIONAL
    /**
     * @brief Internal implementation of set_telem_data() (conditional)
     * 
     * @details Instance method implementing telemetry injection from external
     *          source. Delegates to backend set_telem_data() if backend initialized
     *          and supports bidirectional communication.
     * 
     * @param[in] frame Frame type identifier (uint8_t)
     * @param[in] appid Application ID (uint16_t)
     * @param[in] data Payload data (uint32_t)
     * 
     * @return true if accepted and queued, false otherwise
     * 
     * @note Called by static set_telem_data() wrapper after singleton validation
     * @note Only compiled when HAL_WITH_FRSKY_TELEM_BIDIRECTIONAL defined
     * @see set_telem_data() for public interface documentation
     */
    // set telemetry data from external producer of SPort data (internal function)
    bool _set_telem_data(const uint8_t frame, const uint16_t appid, const uint32_t data);
#endif
    
    /**
     * @brief Deferred singleton creation for external data mode
     * 
     * @details Static method creating singleton when safe for external data mode.
     *          Checks hal.util->get_soft_armed() before initialization to avoid
     *          disrupting armed vehicle. Used when external transport (FPort)
     *          needs telemetry before explicit init() call.
     * 
     *          Initialization deferred until vehicle disarmed to prevent
     *          telemetry disruption during flight.
     * 
     * @note Static method, no instance required for call
     * @note Only used when external transport needs telemetry before explicit init()
     * 
     * @warning Only creates singleton when vehicle disarmed (soft_armed=false)
     * @warning Single creation attempt - does not retry if initially armed
     * 
     * @see hal.util->get_soft_armed() for arming state check
     */
    static void try_create_singleton_for_external_data(void);
    
    /**
     * @brief Static singleton instance pointer (AP_Frsky_Telem*)
     * 
     * @details Singleton instance pointer set by constructor, accessed via
     *          get_singleton() or AP::frsky_telem(). Nullptr until first
     *          instance created.
     * 
     * @note Set by constructor during singleton creation
     * @note Accessed via get_singleton() static method or AP::frsky_telem() wrapper
     */
    static AP_Frsky_Telem *singleton;

};

/**
 * @namespace AP
 * @brief Global namespace for ArduPilot singleton accessors
 */
namespace AP {
    /**
     * @brief Global accessor function for FrSky telemetry singleton
     * 
     * @details Convenience accessor returning AP_Frsky_Telem singleton instance.
     *          Wrapper around AP_Frsky_Telem::get_singleton() providing
     *          consistent AP:: namespace access pattern.
     * 
     * @return AP_Frsky_Telem* pointer to singleton instance, or nullptr if
     *         singleton not yet created
     * 
     * @note Equivalent to AP_Frsky_Telem::get_singleton()
     * @note Returns nullptr if singleton not initialized via init() or
     *       try_create_singleton_for_external_data()
     * 
     * @see AP_Frsky_Telem::get_singleton() for direct singleton access
     */
    AP_Frsky_Telem *frsky_telem();
};

#endif  // AP_FRSKY_TELEM_ENABLED
