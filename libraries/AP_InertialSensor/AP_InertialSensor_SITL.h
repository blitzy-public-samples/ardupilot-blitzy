/**
 * @file AP_InertialSensor_SITL.h
 * @brief Software-In-The-Loop simulation IMU backend
 * 
 * @details Implements simulated IMU backend for SITL testing, providing realistic sensor
 *          data derived from physics simulation with configurable noise and errors.
 *          This backend enables desktop testing of flight control algorithms without
 *          requiring physical hardware, supporting deterministic testing and rapid
 *          development iteration.
 * 
 * @note Only available in SITL builds (AP_SIM_INS_ENABLED)
 */

#pragma once

#include "AP_InertialSensor.h"

#if AP_SIM_INS_ENABLED

#include "AP_InertialSensor_Backend.h"

/**
 * @brief Simulated gyro and accel sample rates in Hz (Type A sensors)
 * @details Matches Pixhawk1 hardware characteristics:
 *          - Element 0: Gyro sample rate (1000 Hz)
 *          - Element 1: Accel sample rate (1000 Hz)
 */
const uint16_t INS_SITL_SENSOR_A[] = { 1000, 1000 };

/**
 * @brief Simulated gyro and accel sample rates in Hz (Type B sensors)
 * @details Matches Pixhawk1 hardware characteristics for secondary IMU:
 *          - Element 0: Gyro sample rate (760 Hz)
 *          - Element 1: Accel sample rate (800 Hz)
 */
const uint16_t INS_SITL_SENSOR_B[] = { 760, 800 };

#include <SITL/SITL.h>

/**
 * @class AP_InertialSensor_SITL
 * @brief Simulation IMU backend for desktop testing
 * 
 * @details Comprehensive IMU simulator supporting desktop testing without hardware.
 *          
 *          Key capabilities:
 *          - Physics-based sensor data from vehicle dynamics simulation
 *          - Realistic sensor noise (white noise, bias drift, random walk)
 *          - Configurable sensor errors (scale factor, misalignment, bias offset)
 *          - Temperature modeling with thermal drift effects
 *          - Vibration injection from motor/propeller harmonic model
 *          - File-based sensor replay for deterministic testing
 *          - Multi-IMU support matching hardware configurations
 *          
 *          Noise modeling:
 *          - Gyro noise: Gaussian white noise + bias random walk
 *          - Accel noise: Gaussian white noise + vibration harmonics from motors
 *          - Temperature drift: Linear temperature coefficient + thermal noise
 *          - Quantization: Simulates 16-bit ADC resolution limits
 *          
 *          Fault injection capabilities:
 *          - Sensor stuck-at failures (simulates hardware lockup)
 *          - Scale factor errors (simulates calibration errors)
 *          - Axis misalignment (simulates mounting errors)
 *          - Bias offset injection (simulates thermal drift extremes)
 *          - Complete sensor dropout (simulates power/connection loss)
 *          
 *          File replay mode:
 *          - Load recorded IMU data from binary file
 *          - Deterministic test execution for regression testing
 *          - Supports gyro and accel data streams separately
 *          
 *          Sample rate simulation:
 *          - Configurable gyro and accel rates (typically 760-1000 Hz)
 *          - Asynchronous sensor updates matching real hardware timing
 *          - Jitter modeling for realistic timing characteristics
 * 
 * @note Only available in SITL builds (HAL_BOARD_SITL)
 * @note Noise parameters tuned to match InvenSense MPU6000/9250 characteristics
 * @warning Simulation fidelity limited by physics model accuracy and update rate
 * @warning File replay mode bypasses physics simulation entirely
 * 
 * @see AP_InertialSensor_Backend for base class interface
 * @see SITL::SIM for physics simulation state
 */
class AP_InertialSensor_SITL : public AP_InertialSensor_Backend
{
public:
    /**
     * @brief Constructor for SITL IMU backend
     * 
     * @param[in] imu Reference to main InertialSensor object
     * @param[in] sample_rates Array of sample rates [gyro_hz, accel_hz]
     * 
     * @note Does not initialize sensor hardware (simulated), call init_sensor() instead
     */
    AP_InertialSensor_SITL(AP_InertialSensor &imu, const uint16_t sample_rates[]);

    /**
     * @brief Update accelerometer and gyroscope state
     * 
     * @details Called at main loop rate to publish new sensor samples to the frontend.
     *          Checks if new samples are available based on simulated sample rates,
     *          retrieves them from the timer update or file replay, and publishes
     *          to the AP_InertialSensor frontend.
     *          
     *          This method does not generate sensor data itself; it only publishes
     *          data that was generated by timer_update() or read from file.
     * 
     * @return true if new samples were published, false otherwise
     * 
     * @note Called at main loop rate (typically 400 Hz for multicopters)
     * @note Non-blocking; returns immediately if no new samples available
     * 
     * @see timer_update() for actual sensor data generation
     */
    bool update() override;

    /**
     * @brief Start the simulated sensor backend
     * 
     * @details Initializes sensor hardware simulation and registers timer callback
     *          for periodic sensor updates. Sets up initial sensor state and prepares
     *          file replay if enabled.
     * 
     * @note Must be called before update() will return valid data
     * @see init_sensor() for initialization details
     */
    void start() override;

    /**
     * @brief Detect and instantiate SITL IMU backend
     * 
     * @details Factory method for creating SITL sensor instances. Always succeeds
     *          in SITL builds since no hardware detection is required.
     * 
     * @param[in] imu Reference to main InertialSensor object
     * @param[in] sample_rates Array of sample rates [gyro_hz, accel_hz]
     * 
     * @return Pointer to new AP_InertialSensor_SITL instance, or nullptr on memory allocation failure
     * 
     * @note This is the standard backend detection interface used by AP_InertialSensor
     * @note In SITL, detection always succeeds (no hardware probe required)
     */
    static AP_InertialSensor_Backend *detect(AP_InertialSensor &imu, const uint16_t sample_rates[]);

private:
    /**
     * @brief Initialize the simulated sensor backend
     * 
     * @details Performs sensor initialization including:
     *          - Registering sensor instances with frontend
     *          - Setting initial calibration state
     *          - Configuring sample rates and timing
     *          - Setting initial temperature
     * 
     * @return true if initialization successful, false otherwise
     * 
     * @note Called during start() before timer registration
     */
    bool init_sensor(void);

    /**
     * @brief Timer callback for periodic sensor updates
     * 
     * @details Called at high rate (typically 1 kHz) to generate new sensor samples.
     *          Checks if it's time to generate new gyro/accel samples based on
     *          configured sample rates, generates sensor data with noise and errors,
     *          and stores for retrieval by update().
     *          
     *          Timing is based on microsecond timestamps to simulate asynchronous
     *          sensor updates matching real hardware behavior.
     * 
     * @note Called from HAL scheduler timer thread at 1 kHz
     * @note Must be fast and deterministic (no blocking operations)
     * 
     * @see generate_gyro() for gyro data generation
     * @see generate_accel() for accel data generation
     */
    void timer_update();

    /**
     * @brief Calculate current gyroscope bias drift
     * 
     * @details Computes gyro bias drift over time using random walk model.
     *          Simulates real gyro behavior where bias changes slowly due to
     *          temperature variations and component aging.
     * 
     * @return Current gyro drift rate in rad/s
     * 
     * @note Drift rate based on gyro quality parameters from SITL configuration
     */
    float gyro_drift(void) const;

    /**
     * @brief Generate simulated accelerometer reading
     * 
     * @details Generates accelerometer data from physics simulation including:
     *          - Vehicle linear acceleration from physics model (body frame)
     *          - Gravity vector in body frame
     *          - Vibration from motor/propeller harmonics
     *          - White noise based on sensor specifications
     *          - Scale factor and misalignment errors
     *          - Bias offset and temperature drift
     *          - ADC quantization effects
     * 
     * @note Generated data stored in backend sample buffer
     * @note Called at configured accel sample rate (typically 800-1000 Hz)
     * 
     * @see timer_update() for timing control
     */
    void generate_accel();

    /**
     * @brief Generate simulated gyroscope reading
     * 
     * @details Generates gyroscope data from physics simulation including:
     *          - Vehicle angular rates from physics model (body frame)
     *          - Vibration effects from motor torque harmonics
     *          - White noise based on sensor specifications
     *          - Bias random walk (drift over time)
     *          - Scale factor and misalignment errors
     *          - Temperature-dependent bias
     *          - ADC quantization effects
     * 
     * @note Generated data stored in backend sample buffer
     * @note Called at configured gyro sample rate (typically 760-1000 Hz)
     * 
     * @see timer_update() for timing control
     * @see gyro_drift() for bias drift calculation
     */
    void generate_gyro();

    /**
     * @brief Get current simulated sensor temperature
     * 
     * @details Returns simulated IMU temperature including:
     *          - Base temperature from SITL environment
     *          - Heating from sensor operation over time
     *          - Thermal noise
     *          
     *          Temperature affects sensor bias and scale factor to model
     *          real thermal drift characteristics.
     * 
     * @return Temperature in degrees Celsius
     * 
     * @note Temperature starts at ambient and increases with runtime
     */
    float get_temperature(void);

    /**
     * @brief Update sensors from file replay
     * 
     * @details If file-based replay is enabled, reads sensor data from files
     *          instead of generating from physics simulation. Used for deterministic
     *          testing with recorded sensor data.
     * 
     * @note Only called when AP_SIM_INS_FILE_ENABLED and files are open
     * @note Bypasses physics simulation entirely
     * 
     * @see read_gyro_from_file()
     * @see read_accel_from_file()
     */
    void update_file();

#if AP_SIM_INS_FILE_ENABLED
    /**
     * @brief Parse gyro samples from file buffer
     * 
     * @param[in] buf Buffer containing gyro samples (x, y, z in rad/s)
     * @param[in] nsamples Number of samples in buffer (each sample is 3 floats)
     * 
     * @note Called by read_gyro_from_file() after reading from file
     */
    void read_gyro(const float* buf, uint8_t nsamples);

    /**
     * @brief Read gyro data from replay file
     * 
     * @details Reads next gyro sample(s) from binary file opened during initialization.
     *          File format: sequence of Vector3f (12 bytes per sample).
     * 
     * @note File path configured via SITL parameters
     * @see write_gyro_to_file() for recording format
     */
    void read_gyro_from_file();

    /**
     * @brief Write gyro data to recording file
     * 
     * @param[in] gyro Gyro sample to write (rad/s in body frame)
     * 
     * @details Records gyro data to binary file for later replay.
     *          File format: sequence of Vector3f (12 bytes per sample).
     * 
     * @note Used for creating deterministic test datasets
     */
    void write_gyro_to_file(const Vector3f& gyro);

    /**
     * @brief Parse accel samples from file buffer
     * 
     * @param[in] buf Buffer containing accel samples (x, y, z in m/s^2)
     * @param[in] nsamples Number of samples in buffer (each sample is 3 floats)
     * 
     * @note Called by read_accel_from_file() after reading from file
     */
    void read_accel(const float* buf, uint8_t nsamples);

    /**
     * @brief Read accel data from replay file
     * 
     * @details Reads next accel sample(s) from binary file opened during initialization.
     *          File format: sequence of Vector3f (12 bytes per sample).
     * 
     * @note File path configured via SITL parameters
     * @see write_accel_to_file() for recording format
     */
    void read_accel_from_file();

    /**
     * @brief Write accel data to recording file
     * 
     * @param[in] accel Accel sample to write (m/s^2 in body frame)
     * 
     * @details Records accel data to binary file for later replay.
     *          File format: sequence of Vector3f (12 bytes per sample).
     * 
     * @note Used for creating deterministic test datasets
     */
    void write_accel_to_file(const Vector3f& accel);
#endif

    /**
     * @brief Pointer to SITL simulation state
     * @details Provides access to vehicle physics state, sensor configuration,
     *          and fault injection parameters
     */
    SITL::SIM *sitl;

    /** @brief Configured gyroscope sample rate in Hz */
    const uint16_t gyro_sample_hz;

    /** @brief Configured accelerometer sample rate in Hz */
    const uint16_t accel_sample_hz;

    /**
     * @brief Next scheduled gyro sample time in microseconds
     * @details Used to maintain accurate sample rate timing in simulation
     */
    uint64_t next_gyro_sample;

    /**
     * @brief Next scheduled accel sample time in microseconds
     * @details Used to maintain accurate sample rate timing in simulation
     */
    uint64_t next_accel_sample;

    /**
     * @brief Accumulated gyro sample time in seconds
     * @details Used for time-dependent noise and drift calculations
     */
    float gyro_time;

    /**
     * @brief Accumulated accel sample time in seconds
     * @details Used for time-dependent noise and vibration calculations
     */
    float accel_time;

    /**
     * @brief Motor phase angles for gyro vibration harmonics
     * @details Tracks phase of each motor (up to 32) for realistic vibration
     *          modeling in gyro data. Updated each sample based on motor RPM.
     */
    float gyro_motor_phase[32];

    /**
     * @brief Motor phase angles for accel vibration harmonics
     * @details Tracks phase of each motor (up to 32) for realistic vibration
     *          modeling in accel data. Updated each sample based on motor RPM.
     */
    float accel_motor_phase[32];

    /**
     * @brief Start time for temperature simulation in milliseconds
     * @details Used to calculate sensor warm-up and thermal drift over time
     */
    uint32_t temp_start_ms;

#if AP_SIM_INS_FILE_ENABLED
    /**
     * @brief File descriptor for gyro replay file
     * @details -1 if file not open, otherwise valid file descriptor for reading/writing
     */
    int gyro_fd = -1;

    /**
     * @brief File descriptor for accel replay file
     * @details -1 if file not open, otherwise valid file descriptor for reading/writing
     */
    int accel_fd = -1;
#endif

    /**
     * @brief Static bus ID counter for multiple IMU instances
     * @details Incremented for each new SITL IMU to provide unique bus IDs
     *          matching real hardware multi-IMU configurations
     */
    static uint8_t bus_id;
};
#endif // AP_SIM_INS_ENABLED
