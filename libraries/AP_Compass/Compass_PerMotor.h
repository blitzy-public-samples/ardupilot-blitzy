/**
 * @file Compass_PerMotor.h
 * @brief Per-motor compass interference compensation system
 * 
 * @details This module provides real-time compensation for magnetic interference
 *          generated by individual motors in multirotor aircraft. Each motor's
 *          magnetic field contribution is characterized during a calibration
 *          procedure and compensated during flight based on motor throttle
 *          commands, battery voltage, and ESC non-linearities.
 * 
 *          The system addresses the common problem where motor currents create
 *          magnetic fields that interfere with the compass, causing heading
 *          errors that vary with motor throttle. This is particularly important
 *          for multirotors with close-coupled motors and compass.
 * 
 * @note Currently supports quadcopters only (4 motors) and single magnetometer
 * 
 * Source: libraries/AP_Compass/Compass_PerMotor.h
 * Source: libraries/AP_Compass/Compass_PerMotor.cpp
 */

#include <AP_Math/AP_Math.h>


class Compass;

/**
 * @class Compass_PerMotor
 * @brief Per-motor compass interference compensation for multirotors
 * 
 * @details This class implements individual motor magnetic interference vector
 *          calibration and real-time compensation. The compensation system:
 *          
 *          1. **Calibration Phase**: Each motor is commanded individually while
 *             measuring the resulting magnetic field interference. The system
 *             computes a 3D compensation vector for each motor representing
 *             the magnetic field generated per unit of scaled motor output.
 *          
 *          2. **Compensation Phase**: During flight, the system calculates the
 *             total magnetic interference offset by summing each motor's
 *             compensation vector scaled by that motor's current output. The
 *             scaled output accounts for:
 *             - PWM throttle command (0-1 range)
 *             - Battery voltage (interference proportional to motor current)
 *             - ESC non-linearities (exponential scaling factor)
 *          
 *          3. **Real-time Application**: The computed interference offset is
 *             applied to the raw compass readings to remove motor-induced
 *             magnetic field distortions.
 * 
 * @par Calibration Procedure
 *      - System records base magnetic field with motors off
 *      - Each motor is commanded to various throttle levels individually
 *      - Magnetic field changes are measured and correlated with motor output
 *      - Compensation vectors computed as: change_in_field / scaled_output
 *      - Vectors stored persistently via AP_Param system
 * 
 * @par Motor Output Scaling
 *      The scaled motor output used for compensation is calculated as:
 *      @code
 *      output = ((pwm_normalized + 1) / 2) * voltage * pow(base_output, expo)
 *      @endcode
 *      This accounts for voltage variations and non-linear ESC response.
 * 
 * @par Field Units
 *      All magnetic field vectors and compensation vectors are in milligauss.
 * 
 * @par Typical Applications
 *      - Multirotors with close-coupled motors and compass (motors < 20cm from compass)
 *      - High-current motors (> 20A) with significant magnetic signatures
 *      - Aircraft requiring precision heading during aggressive maneuvers
 *      - Systems where standard compass-motor calibration is insufficient
 * 
 * @warning Motor magnetic interference can cause significant heading errors
 *          (10+ degrees) if not compensated. Improper calibration can make
 *          heading errors worse. Always verify compensation improves heading
 *          accuracy across throttle range before flight.
 * 
 * @note This class is currently limited to quadcopters (4 motors) and single
 *       magnetometer. Multi-mag systems use only the primary compass (index 0).
 * 
 * Source: libraries/AP_Compass/Compass_PerMotor.cpp:95-231
 */
class Compass_PerMotor {
public:
    /**
     * @brief AP_Param variable info table for parameter persistence
     * 
     * @details Defines parameters:
     *          - _EN: Enable/disable per-motor compensation (0=Disabled, 1=Enabled)
     *          - _EXP: Exponential correction factor for ESC non-linearity (0-2, default 0.65)
     *          - 1_X, 1_Y, 1_Z: Motor 1 compensation vector (X, Y, Z in milligauss)
     *          - 2_X, 2_Y, 2_Z: Motor 2 compensation vector (X, Y, Z in milligauss)
     *          - 3_X, 3_Y, 3_Z: Motor 3 compensation vector (X, Y, Z in milligauss)
     *          - 4_X, 4_Y, 4_Z: Motor 4 compensation vector (X, Y, Z in milligauss)
     * 
     * Source: libraries/AP_Compass/Compass_PerMotor.cpp:11-92
     */
    static const struct AP_Param::GroupInfo var_info[];

    /**
     * @brief Construct per-motor compass compensation object
     * 
     * @param[in] _compass Reference to main Compass object for accessing magnetometer readings
     * 
     * @details Initializes per-motor compensation system and sets up AP_Param
     *          defaults for all parameters. Links to the primary Compass object
     *          to obtain real-time magnetic field measurements.
     * 
     * Source: libraries/AP_Compass/Compass_PerMotor.cpp:95-99
     */
    Compass_PerMotor(Compass &_compass);

    /**
     * @brief Check if per-motor compensation is enabled
     * 
     * @return true if compensation is enabled (enable parameter non-zero)
     * @return false if compensation is disabled
     * 
     * @details Queries the enable parameter to determine if real-time
     *          compensation should be applied. Typically enabled after
     *          successful calibration.
     */
    bool enabled(void) const {
        return enable.get() != 0;
    }
    
    /**
     * @brief Update battery voltage estimate for compensation scaling
     * 
     * @param[in] _voltage Current battery voltage in volts
     * 
     * @details Motor magnetic interference is proportional to current, which
     *          varies with voltage. This method applies a simple low-pass filter
     *          to track battery voltage:
     *          @code
     *          filtered_voltage = 0.9 * old_voltage + 0.1 * new_voltage
     *          @endcode
     *          The filtered voltage is used to scale motor output in compensation
     *          calculations. Should be called regularly (e.g., main loop rate).
     * 
     * @note Simple first-order low-pass filter with time constant ~10 samples
     */
    void set_voltage(float _voltage) {
        // simple low-pass on voltage
        voltage = 0.9f * voltage + 0.1f * _voltage;
    }

    /**
     * @brief Start per-motor calibration procedure
     * 
     * @details Initializes calibration state by:
     *          - Zeroing accumulation arrays for all 4 motors
     *          - Discarding several compass samples to ensure fresh data
     *          - Recording baseline magnetic field with motors off
     *          - Setting calibration running flag
     * 
     *          After calling this, the system expects each motor to be commanded
     *          individually while calibration_update() is called regularly.
     * 
     * @note Compass offsets should be calibrated before per-motor calibration
     * @warning Ensure aircraft is stationary and away from magnetic interference sources
     * 
     * @see calibration_update()
     * @see calibration_end()
     * 
     * Source: libraries/AP_Compass/Compass_PerMotor.cpp:135-154
     */
    void calibration_start(void);
    
    /**
     * @brief Update per-motor calibration with current motor outputs
     * 
     * @details Called repeatedly during calibration (typically at ~10-50Hz).
     *          For each motor that is running:
     *          - Waits 500ms for motor magnetic field to settle
     *          - Accumulates magnetic field samples (from primary compass)
     *          - Accumulates scaled motor output values
     *          - Increments sample count
     * 
     *          The calibration procedure commands each motor individually to
     *          various throttle levels while this method accumulates the
     *          correlation between motor output and magnetic field distortion.
     * 
     * @note Each motor must run for at least 500ms before samples are accumulated
     * @note Only accumulates data while individual motors are active
     * 
     * @see calibration_start()
     * @see calibration_end()
     * 
     * Source: libraries/AP_Compass/Compass_PerMotor.cpp:157-183
     */
    void calibration_update(void);
    
    /**
     * @brief Complete calibration and compute compensation vectors
     * 
     * @details Finalizes per-motor calibration by:
     *          - Computing average field change for each motor
     *          - Computing average scaled output for each motor
     *          - Calculating compensation vector: field_change / output
     *          - Saving compensation vectors to persistent storage (AP_Param)
     *          - Enabling per-motor compensation
     * 
     *          Compensation vectors represent the magnetic field contribution
     *          (in milligauss) per unit of scaled motor output. During flight,
     *          these vectors are scaled by current motor output and summed to
     *          compute the total interference offset.
     * 
     * @note Automatically enables compensation (sets enable parameter to 1)
     * @note Vectors are saved to EEPROM/flash via AP_Param::set_and_save()
     * 
     * @see calibration_start()
     * @see calibration_update()
     * @see compensate()
     * 
     * Source: libraries/AP_Compass/Compass_PerMotor.cpp:186-210
     */
    void calibration_end(void);
    
    /**
     * @brief Calculate current motor interference offset
     * 
     * @param[out] offset Computed 3D magnetic interference offset in milligauss
     * 
     * @details Computes the total magnetic field interference from all motors
     *          based on current motor throttle commands. For each motor:
     *          - Obtains current scaled output (PWM * voltage * expo)
     *          - Scales that motor's compensation vector by output
     *          - Sums contributions from all 4 motors
     * 
     *          The resulting offset should be subtracted from (or equivalently,
     *          added with opposite sign to) raw compass readings to remove
     *          motor-induced magnetic interference.
     * 
     *          Formula:
     *          @code
     *          offset = sum(compensation[i] * scaled_output[i]) for i=0..3
     *          @endcode
     * 
     * @note Returns zero offset if compensation is disabled or calibration is running
     * @note Called at main loop rate (typically 400Hz for copters)
     * 
     * Source: libraries/AP_Compass/Compass_PerMotor.cpp:215-231
     */
    void compensate(Vector3f &offset);
    
private:
    /**
     * @brief Reference to main Compass object
     * 
     * @details Used to obtain real-time magnetic field measurements from the
     *          primary magnetometer (compass index 0) during calibration and
     *          compensation.
     */
    Compass &compass;
    
    /**
     * @brief Enable/disable parameter for per-motor compensation
     * 
     * @details AP_Param parameter (COMPASS_PMOT_EN) controlling whether
     *          real-time compensation is active. Set to 1 during calibration_end().
     *          Values: 0=Disabled, 1=Enabled
     */
    AP_Int8 enable;
    
    /**
     * @brief Exponential correction factor for ESC non-linearity
     * 
     * @details AP_Param parameter (COMPASS_PMOT_EXP) modeling non-linear ESC
     *          response. Motor output is raised to this power to account for
     *          ESC throttle curves and motor/propeller efficiency variations.
     *          
     *          Typical values:
     *          - 0.65: Default, models typical ESC non-linearity
     *          - 1.0: Linear response (no correction)
     *          - <1.0: Accounts for reduced efficiency at low throttle
     * 
     *          Range: 0.0 to 2.0
     *          Source: libraries/AP_Compass/Compass_PerMotor.cpp:19-25
     */
    AP_Float expo;
    
    /**
     * @brief Per-motor compensation vectors (4 motors)
     * 
     * @details AP_Param 3D vectors storing magnetic field interference per unit
     *          of scaled motor output for each motor. Units: milligauss per
     *          scaled output unit. Computed during calibration, applied during
     *          compensation. Persisted to EEPROM/flash.
     * 
     *          Parameters: COMPASS_PMOT1_{X,Y,Z}, COMPASS_PMOT2_{X,Y,Z},
     *                      COMPASS_PMOT3_{X,Y,Z}, COMPASS_PMOT4_{X,Y,Z}
     */
    AP_Vector3f compensation[4];

    /**
     * @brief Baseline magnetic field recorded at calibration start
     * 
     * @details Reference field measurement (milligauss) taken with motors off.
     *          Used to compute field changes during calibration:
     *          field_change = base_field - measured_field_with_motor_on
     */
    Vector3f base_field;
        
    /**
     * @brief Accumulated magnetic field samples during calibration (4 motors)
     * 
     * @details Sum of compass readings (milligauss) for each motor during
     *          calibration. Averaged at calibration_end() to compute mean
     *          field with each motor running.
     */
    Vector3f field_sum[4];

    /**
     * @brief Accumulated scaled motor output during calibration (4 motors)
     * 
     * @details Sum of scaled output values (PWM * voltage^expo) for each motor
     *          during calibration. Averaged at calibration_end() to compute
     *          mean output for each motor's test run.
     */
    float output_sum[4];
        
    /**
     * @brief Sample count for calibration accumulation (4 motors)
     * 
     * @details Number of samples accumulated for each motor. Used to compute
     *          averages: mean_field = field_sum / count,
     *          mean_output = output_sum / count
     */
    uint16_t count[4];

    /**
     * @brief Motor start timestamp in milliseconds (4 motors)
     * 
     * @details AP_HAL::millis() timestamp when each motor started running during
     *          calibration. Used to enforce 500ms settling time before accumulating
     *          samples. Zero indicates motor is not currently running.
     */
    uint32_t start_ms[4];
        
    /**
     * @brief Filtered battery voltage in volts
     * 
     * @details Low-pass filtered voltage estimate used to scale motor output
     *          in compensation. Motor current (and thus magnetic interference)
     *          is proportional to voltage. Updated via set_voltage().
     */
    float voltage;

    /**
     * @brief Calibration running flag
     * 
     * @details True during calibration (between calibration_start() and
     *          calibration_end()). When true, compensate() returns zero offset
     *          to avoid interfering with calibration measurements.
     */
    bool running;

    /**
     * @brief Get scaled motor output for compensation
     * 
     * @param[in] motor Motor index (0-3)
     * 
     * @return Scaled motor output (dimensionless, typically 0-15 range)
     * @return 0 if motor map unavailable or motor is off
     * 
     * @details Computes scaled motor output accounting for:
     *          - PWM throttle command normalized to 0-1 range
     *          - Battery voltage (proportional to current/interference)
     *          - Exponential correction for ESC non-linearity
     * 
     *          Formula:
     *          @code
     *          pwm_normalized = (esc_to_unity(pwm) + 1) / 2  // 0 to 1
     *          scaled = pwm_normalized * voltage * pow(pwm_normalized * voltage, expo)
     *          @endcode
     * 
     * @note Requires motor map to be initialized (mapping motor index to servo output channel)
     * 
     * Source: libraries/AP_Compass/Compass_PerMotor.cpp:102-132
     */
    float scaled_output(uint8_t motor);

    /**
     * @brief Motor map initialization flag
     * 
     * @details True once motor output channel mapping has been successfully
     *          established from SRV_Channel system (k_motor1 through k_motor4).
     */
    bool have_motor_map;
    
    /**
     * @brief Motor index to servo output channel mapping (4 motors)
     * 
     * @details Maps motor index (0-3) to servo output channel number for
     *          reading PWM values. Populated from SRV_Channel system by
     *          finding channels assigned to k_motor1 through k_motor4 functions.
     */
    uint8_t motor_map[4];
};

